#!/usr/bin/env python
# remove the necessity to have .py extension

from PIL import Image
import sys
import os.path
import numpy as np
import math
import matplotlib.pyplot as plt  # Just so we can visually confirm we have the same images


option_handle_list = []
option_unique_list = ['--info', '--verbose']
options = {}


if not os.path.exists(sys.argv[1]):
    raise ValueError("Incorrect path, image path must be the first argument")
imagePath = sys.argv[1]

for option_handle in option_handle_list:
    if option_handle in sys.argv:
        options[option_handle[2:]] = sys.argv[sys.argv.index(option_handle) + 1]
    else:
        options[option_handle[2:]] = None

for option_handle in option_unique_list:
    if option_handle in sys.argv:
        options[option_handle[2:]] = True
    else:
        options[option_handle[2:]] = None




if options['info'] != None:
    print("Function cropImage.")
    print("USAGE : cropImageImage [imagePath] [options]")
    print("")
    exit()


if options['verbose']:
    np.set_printoptions(threshold=sys.maxsize) #writing entire data (not splitting) may consume time

img = Image.open(imagePath)
print("number of images found : ", img.n_frames)
images = []
for i in range(img.n_frames): #number of images
    img.seek(i)
    if options['verbose']:
        print("----------- image " + str(i) + "-----------")
        print("format : " + str(img.format))
        print("size : " + str(img.size))
        print("mode : " + str(img.mode))
    npyImage = np.array(img)
    images.append(npyImage)



imageToTreat = images[1]
print(type(images[1]))
print(images[1], images[1].dtype)

print(len(images[0]), len(images[0][0]))

yColumns = len(images[0])/128
xColumns = len(images[0][0])/128


valuesImage = images[0].flatten()
max = np.amax(valuesImage)
min = np.amin(valuesImage)
print("Range :", min, max)
threshold = min + (max - min) / 10 #rejetting the then lowest percent


result = []
for y in range(0, xColumns):
    for x in range(0, yColumns):
        save = False
        temp = np.ndarray(shape=(128,128), dtype="uint16")
        for i in range(y * 128, (y + 1) * 128 - 1 ):
            for j in range(x * 128, (x + 1) * 128 - 1):
                temp[i - y * 128][j - x * 128] = images[0][i][j]
                if images[0][i][j] > threshold:
                    save = True
        if save:
            print("saved --> y:", y, " x:", x)
        result.append(temp)

sqrt = math.ceil(math.sqrt(len(result)))
fig = plt.figure(figsize=(sqrt, sqrt))
for i in range(1, len(result) + 1):
    fig.add_subplot(sqrt, sqrt, i)
    plt.imshow(result[i - 1])
plt.show()

# for indexY, valueX in enumerate(images[1]):
#     if indexY < 128:
#         for indexX, valueY in enumerate(images[1][indexY]):
#             if indexX < 128:
#                 result[indexY][indexX] = valueY
# plt.imshow(result)
# plt.show()
#
# result = np.ndarray(shape=(128,128), dtype="uint16")


# for indexY, valueX in length(images[1]):
#     if indexY > 127 and indexY < 256:
#         for indexX, valueY in enumerate(images[1][indexY]):
#             if indexX < 128:
#                 result[indexY - 128 ][indexX] = valueY
# plt.imshow(result)
# plt.show()

# sqrt = math.ceil(math.sqrt(img.n_frames))
# fig = plt.figure(figsize=(sqrt, sqrt))
# for i in range(1, img.n_frames +1):
#     fig.add_subplot(sqrt, sqrt, i)
#     plt.imshow(images[i - 1])
# plt.show()
